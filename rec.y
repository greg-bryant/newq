%{/* rec.y -- yacc description for newq's recspec string sub-translator.	'yy' is replaced by 'yy1' in all names. Other name conflicts between	newq and recspec are resolved with and 'r' in front of the latter	names.	See rec.l for additional info.*//* Greg Bryant, 1986. */#include "pdq.h"#include "pardef.h"#include "pdqrtc.h"#include ctypeextern char *up_string();noshare struct node {	short s_or_p;	int attr;	union {		char *str;		struct node *ptr;		char *tok;	} val ;} *rnode;#define nodal(x) rnind=0;rnode=pdq__nodes_al(x)#define STR	0		/* string flag for a node */#define PTR	1		/* pointer flag for a node */#define TOK	2		/* a mallocked string from lex (token) */#define sn(y) rnode[rnind].s_or_p=STR;rnode[rnind++].val.str=y#define pn(y) rnode[rnind].s_or_p=PTR;rnode[rnind++].val.ptr=y#define tn(y) rnode[rnind].s_or_p=TOK;rnode[rnind++].val.tok=ytypedef struct node *stacktype;#define YYSTYPE stacktypenoshare extern char *object_string;noshare extern char *base_range;noshare char *rec_string = "";	/* input to rec lex/yacc pair through rec_getc */noshare struct node *rec_out = "";		/* returned relational DB qual string */noshare char *rec_table = "";	/* current range pointer for the rec expansion */noshare int record_flag;	/* set if rec_table is 'record' */noshare int rnind;noshare int rs_ind = 0;		/* index to rec_string */%}%token NAME%%recspec: rec_string	{		rec_out = $1;	}	;rec_string: id_string spec_string		{			nodal(5);			sn(" ( ");			pn($1);			sn(" and \n");			pn($2);			sn(" ) ");			$$ = rnode;		}		;id_string: type '\\' name		{			nodal(6);			pn($1);			sn(" and \n");			pn($3);			sn(" and \n");			sn(rec_table);			sn(".recalt = \"\"");			$$ = rnode;		}	| type '\\' name '\\' 		{			nodal(6);			pn($1);			sn(" and \n");			pn($3);			sn(" and \n");			sn(rec_table);			sn(".recalt = \"\"");			$$ = rnode;		}	| type '\\' name '\\' alt		{			nodal(5);			pn($1);			sn(" and \n");			pn($3);			sn(" and \n");			pn($5);			$$ = rnode;		}	;spec_string: /* nothing */		{			if (!record_flag) {				nodal(2);				sn(rec_table);				sn(".recver = -2 ");			} else {				nodal(4);				sn(rec_table);				sn(".latest = ");				sn(rec_table);				sn(".objid ");			}			$$ = rnode;		}	| ';'		{			if (!record_flag) {				nodal(2);				sn(rec_table);				sn(".recver = -2 ");			} else {				nodal(4);				sn(rec_table);				sn(".latest = ");				sn(rec_table);				sn(".objid ");			}			$$ = rnode;		}	| ';' '@' basename		{			if(!record_flag) {				nodal(3);				sn(rec_table);				sn(".recver = -2 and \n");				pn($3);			} else {				nodal(9);				sn(rec_table);				sn(".recver = max(");				sn(rec_table);				sn(".recver where (");				sn(rec_table);				sn(".latest = ");				sn(rec_table);				sn(".objid)) and \n");				pn($3);			}			$$ = rnode;		}	| '@' basename		{			if(!record_flag) {				nodal(3);				sn(rec_table);				sn(".recver = -2 and \n");				pn($2);			} else {				nodal(9);				sn(rec_table);				sn(".recver = max(");				sn(rec_table);				sn(".recver where (");				sn(rec_table);				sn(".latest = ");				sn(rec_table);				sn(".objid)) and \n");				pn($2);			}			$$ = rnode;		}	| ';' version '@' basename		{			nodal(3);			pn($2);			sn(" and \n");			pn($4);			$$ = rnode;		}	| ';' version 		{			$$ = $2;		}	;type:	NAME		{			nodal(4);			sn(rec_table);			sn(".rectype = \"");			up_string($1);			tn($1);			sn("\" ");			$$ = rnode;		}	;name :  NAME		{			nodal(4);			sn(rec_table);			sn(".recname = \"");			up_string($1);			tn($1);			sn("\" ");			$$ = rnode;		}	;alt:	NAME		{			nodal(4);			sn(rec_table);			sn(".recalt = \"");			up_string($1);			tn($1);			sn("\" ");			$$ = rnode;		}	;version: NAME	{		int i = 0, semaphor  = 0;		char *str1;		if ( !strcmp($1,"*") ) {			if (!record_flag) {								nodal(2);				sn(rec_table);				sn(".recver = -1 ");			} else {				nodal(2);				sn(rec_table);				sn(".recver > 0 ");			}			$$ = rnode;		} else {			str1 = $1;			for ( i=0;  str1[i]; i++ ) {				if ( !isdigit( str1[i] ) ) {					semaphor = 1;				}			}			if (!semaphor) {				nodal(4);				sn(rec_table);				sn(".recver = ");				tn($1);				sn(" ");				$$ = rnode;			} else { yyerror(); }		}	}	;basename: NAME		{			nodal(4);			sn(rec_table);			sn(".reclevel = \"");			up_string($1);			tn($1);			sn("\" ");			$$ = rnode;		}	;%%#include "lexy.c"struct node *parse_rec(s,t)char *s,*t;{	int len;	len = strlen(s);	rec_string = strip_copy((char *)malloc(len*sizeof(char)),s);	rec_table = t;	rs_ind = 0;	yychar = -1;	yyerrflag = 0;	yyprevious = YYNEWLINE;	yylineno = 1;	yyleng = 0;	yymorfg = 0;	yytchar = 0;	yysptr = yysbuf;	record_flag = 0;	if (!up_strcmp(get_table(rec_table),RECORD_STRING)) {		record_flag = 1;	}	yyparse();	return rec_out;}yyerror(){	cancel(RCPDQ_REC);}