%{/* newq.y -- yacc syntactical description for a new query language. *//* Greg Bryant, 1986 */#ifndef VMS#define noshare#endifnoshare struct node {	short s_or_p;	int attr;	union {		char *str;		struct node *ptr;		char *tok;	} val ;} *node;#define nodal(x) nind=0;node=pdq__nodes_al(x)#define STR	0		/* string flag for a node */#define PTR	1		/* pointer flag for a node */#define TOK	2#define UC	3#define NO_U	4#define sn(y) node[nind].s_or_p=STR;node[nind++].val.str=y#define pn(y) node[nind].s_or_p=PTR;node[nind++].val.ptr=y#define tn(y) node[nind].s_or_p=TOK;node[nind++].val.tok=y#define CLAUSE_END 150 /* The length of the text to join a	range variable to the base table, multiplied by 10,	the number of non-base table ranges currently possible. */typedef struct node *stacktype;#define YYSTYPE stacktype#define ON 1#define OFF 0noshare char *current_range, *base_range, *range_al(), *reserve_range;noshare int brace_state = 0;noshare int nind;%}%token NAME STRING NUMBER GTE LTE NEQ WHERE BY SORT %left OR AND NOT%left UNARYMINUS UNARYPLUS%right TO_THE%right '*' , '/'%right '+' , '-'%%start: qual sort_by		{			if (newq_return == OK) {				uc_subtree($1);				nodal(6);				sn(" ( ( ");				pn($1);				pn(" ) ");				pn(base_joins());				sn(" ) ");				pn($2);				newq_out = tree_to_str(node);			}		}	| qual		{			if (newq_return == OK) {				uc_subtree($1);				nodal(5);				sn(" ( ( ");				pn($1);				pn(" ) ");				sn(base_joins());				sn(" ) ");				newq_out = tree_to_str(node);			}		}	;qual: clause	{		nodal(3);		sn(" ( ");		pn($1);		sn(" ) ");	}	| NOT qual		{				nodal(2);			sn(" NOT ");			pn($2);			$$ = node;		}	| qual OR qual		{				nodal(3);			pn($1);			sn(" OR ");			pn($3);			$$ = node;		}	| qual AND qual		{				nodal(3);			pn($1);			sn(" and \n");			pn($3);			$$ = node;		}	| '(' qual ')'		{				nodal(3);			sn(" ( ");			pn($2);			sn(" ) ");			$$ = node;		}	| NAME '.' '{' 		{			if (brace_state == ON) {				yyerror();			}			brace_state = ON;		/*	if (a_o_flag == ON) {				brace_range = a_o_r_al($1);			} else {  */				brace_range = range_al($1);				/*	}   */		}	qual '}'		{				brace_state = OFF;			nodal(3);			sn(" ( ");			pn($5);			sn(" ) \n");			$$ = node;		}	;name_com_list:  name	| name_com_list ',' name	{		nodal(3);		pn($1);		sn(" , ");		pn($3);		$$ = node;	}	;clause: expr '<' expr		{				nodal(3);			pn($1);			sn(" < ");			pn($3);			$$ = node;		}	| expr '>' expr		{				nodal(3);			pn($1);			sn(" > ");			pn($3);			$$ = node;		}	| expr '=' expr		{				char *s;			if (($1[0].s_or_p == TOK) &&			    (!up_strcmp("recspec",$1[0].val.str))) {				if (brace_state == ON) {					s = current_range;				} else {					s = base_range;				}				$$ = parse_rec($3[0].val.str,s);			} else {				if (($1[2].s_or_p == TOK) &&				   (!up_strcmp("recspec",$1[2].val.str))) {					s = $1[0].val.str;					$$ = parse_rec($3[0].val.str,s);				} else {					nodal(3);					pn($1);					sn(" = ");					pn($3);					$$ = node;				}			}		}	| expr GTE expr		{				nodal(3);			pn($1);			sn(" >= ");			pn($3);			$$ = node;		}	| expr LTE expr		{				nodal(3);			pn($1);			sn(" <= ");			pn($3);			$$ = node;		}	| expr NEQ expr		{				nodal(3);			pn($1);			sn(" != ");			pn($3);			$$ = node;		}	;expr: name	{			if (!up_strcmp("reservedesc",$1[2].val.tok)) {				$1[2].attr = NO_U;			}			if (!up_strcmp("value",$1[2].val.tok)) {				$1[2].attr = NO_U;			}			if (!up_strcmp("desc",$1[2].val.tok)) {				$1[2].attr = NO_U;			}			if (!up_strcmp("node",$1[2].val.tok)) {				$1[2].attr = NO_U;			}			if (!up_strcmp("directory",$1[2].val.tok)) {				$1[2].attr = NO_U;			}			if (!up_strcmp("mail",$1[2].val.tok)) {				$1[2].attr = NO_U;			}			if (!up_strcmp("source",$1[2].val.tok)) {				$1[2].attr = NO_U;			}			if (!up_strcmp("arcset",$1[2].val.tok)) {				$1[2].attr = NO_U;			}			if (!up_strcmp("alias",$1[2].val.tok)) {				$1[2].attr = NO_U;			}	}	| STRING		{				nodal(1);			tn($1);			node[nind-1].attr = UC;			$$ = node;		}	| NUMBER		{				nodal(1);			tn($1);			$$ = node;		}	| NAME '('		{			a_o_flag = ON; 		}	 agg_op_par ')'		{			a_o_flag = OFF; 			nodal(5);			tn($1);			sn(" ( ");			pn($4);			pn(a_o_base_joins());			sn(" ) ");			$$ = node;		}	| expr '+' expr		{				nodal(3);			pn($1);			sn(" + ");			pn($3);			$$ = node;		}	| expr '-' expr		{				nodal(3);			pn($1);			sn(" - ");			pn($3);			$$ = node;		}	| expr '*' expr		{				nodal(3);			pn($1);			sn(" * ");			pn($3);			$$ = node;		}	| expr '/' expr		{				nodal(3);			pn($1);			sn(" / ");			pn($3);			$$ = node;		}	| expr TO_THE expr		{				nodal(3);			pn($1);			sn(" ** ");			pn($3);			$$ = node;		}	| '-' expr %prec UNARYMINUS 		{				nodal(2);			sn(" -");			pn($2);			$$ = node;		}	| '+' expr %prec UNARYPLUS		{				nodal(2);			sn(" +");			pn($2);			$$ = node;		}	| '(' expr ')'		{				nodal(3);			sn("( ");			pn($2);			sn(" ) ");			$$ = node;		}	;agg_op_par:  expr BY name_com_list WHERE qual		{			nodal(5);			pn($1);			sn(" by ");			pn($3);			sn(" where ");			pn($5);			$$ = node;		}	| expr WHERE qual		{			nodal(3);			pn($1);			sn(" where ");			pn($3);			$$ = node;		}	| expr BY name_com_list		{			nodal(3);			pn($1);			sn(" by ");			pn($3);			$$ = node;		}	| expr		{			$$ = $1;		}		;name: NAME	{		if (brace_state == OFF) {			/* note: reserve attributes and base attributes and 				recspec all make no sense within braces */			/* reserve attribute */			if ((!up_strcmp("keyname",$1)) ||				(!up_strcmp("reserveuser",$1)) ||				(!up_strcmp("reservedate",$1)) ||				(!up_strcmp("reservedesc",$1)) )  {				if (reserve_flag != ON) {				  if (pool_ind >= RANGE_LIMIT) {					cancel(RCPDQ_RANGE);				  } else {					if (pdb__archive) 						pdb__range(range_pool[pool_ind],							"Zreserve");					else pdb__range(range_pool[pool_ind],							"reserve");					reserve_range = range_pool[pool_ind++];					reserve_flag = ON;				  }				}				nodal(3);				sn(reserve_range);				sn(".");				tn($1);			} else {				/* recspec virtual attribute */				if (!up_strcmp("recspec",$1)) {						nodal(3);					tn($1);					sn("");					sn("");				} else {					/* base table attribute */					/* note: later, for efficiency,					don't allocate a range for base					unless they are used AND some					other table is too. */					nodal(3);					sn(base_range);					sn(".");					tn($1);				}			}		} else {			/* attribute in braces */			/* note all the checks that need to be put here				watching for the above keywords to				error on */				nodal(3);			sn(brace_range);			sn(".");			tn($1);		}		$$ = node;	}	| NAME '.' NAME	{		/* one of these inside braces is a syntax error */		if (brace_state == ON) {			yyerror();		}		nodal(3);		/* allocate new range for new 'table.attribute' *//*		if (a_o_flag == ON) {			sn(a_o_r_al($1));		} else {  */			sn(range_al($1));/*		} */		sn(".");		tn($3);		$$ = node;	}	;sort_by: SORT sort_list	{		nodal(2);		sn(" sort ");		pn($2);		$$ = node;	}	| SORT BY sort_list	{		nodal(2);		sn(" sort by ");		pn($3);		$$ = node;	}	;sort_list: sort_key	| sort_list ',' sort_key	{		nodal(3);		pn($1);		sn(" , ");		pn($3);		$$ = node;	}	;sort_key: name	| name ':' NAME	{		nodal(3);		pn($1);		sn(" : ");		tn($3);		$$ = node;	}	;%%#include "pdq_lexy.c"#include "pdq.c"