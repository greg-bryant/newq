/* pdq.c - pdb_conv_dynamic_qual() and all supporting c code for	newq and rec *//* Greg Bryant, 1986. */#include "pardef.h"#include "pdbdef.h"#include "pdbstr.h"#include "pdqrtc.h"#include "pdq.h"#include <ctype.h>#define OS_PTR_LIMIT	50#define OS_STRING_SIZE  512#define RANGE_LIMIT 	10	#define NODE_LIMIT 	2000 	/* maximum number of nodes used in				one call to this layer */#define jsn(y) joins[jind].s_or_p=STR;joins[jind++].val.str=y#define jtn(y) joins[jind].s_or_p=TOK;joins[jind++].val.tok=y#define ajsn(y) a_o_joins[jind].s_or_p=STR;a_o_joins[jind++].val.str=y#define ajtn(y) a_o_joins[jind].s_or_p=TOK;a_o_joins[jind++].val.tok=ynoshare int node_space_ind = 0;noshare struct node node_space[NODE_LIMIT];noshare struct node *dummy;noshare struct node dummy_node;noshare extern 	int yy1char, 	/* this chunk of externs is for */	yy1previous,  	/* re-initializing for the next round. */	yy1lineno;noshare extern short yy1errflag;noshare extern int yy1leng,	yy1morfg,	yy1tchar;noshare extern char	*rec_out,	*rec_table,	*yy1sptr,	*yy1sbuf;noshare int	newq_return;    /* return value (OK or error code) */noshare int	ns_ind = 0;	/* newq_getc's index to newq_string */noshare int 	object;		/* current object */noshare int	reserve_flag = OFF;	/* reserve attributes have been used */noshare int	recspec_state = OFF;	/* to tell qual n.t. tht previous						clause was recspec */noshare int 	a_o_flag = OFF;noshare int 	os_ptr_ind = 0;	/* indexes for out_str. Main... */noshare int 	os_char_ind = 0;	/* ...and secondary.     */noshare int 	range_ind = 0;noshare int	a_o_r_ind = 0;noshare int	pool_ind = 0;noshare char 	*newq_string,	/* input string to be parsed */	        *newq_out;	/* resulting output string for relational DB */noshare char 	*strip_copy(),	        *flat_copy(),	        *object_to_string();noshare char 	*object_string; /* current object in string form */noshare char 	*out_str[OS_PTR_LIMIT];	/* an array of character strings */noshare char 	*brace_range;noshare char	*pdb_join_table;noshare extern 	int rs_ind;noshare extern 	char *rec_string;noshare char	*range_pool[RANGE_LIMIT+1];noshare struct range_list {	char *table;	char *range;	int mark;} range_list[RANGE_LIMIT+1], a_o_r_list[RANGE_LIMIT+1];/* pdq_conv_dynamic_qual -- routine for calling this translator,    to translate these new queries into relational DB qualifiers.    Strips off quotes from DCL. Initializes input and output strings.    Calls yyparse. Returns error code. */pdq_conv_dynamic_qual(obj,string,outq,table)int obj;char *string,**outq,**table;{	object = obj;	newq_string = string;	init();	yyparse();	*outq = newq_out;	*table = pdb_join_table;	return newq_return;}/* strip_copy -- copy 's' into 'd' stripping off the first and last 	characters in 's' */char *strip_copy(d,s)char *d, *s;{	char *d_ptr;	d_ptr = d;	s++;	while (*s) *d++ = *s++;	*--d = '\0';	return d_ptr;}/* pdq__nodes_al -- allocate an array of nodes */struct node *pdq__nodes_al(i)int i;	/* number of nodes */{	struct node *n;	int j;	n = &node_space[node_space_ind];	for (j=0;j<=i;j++) {		n[j].attr = 0;	}	n[i].val.ptr = (struct node *) 0;	node_space_ind += (i+1); 	if (node_space_ind > NODE_LIMIT) {		printf("Need higher node limit.\n\r");		exit(0);	}	return n;}/* tree_to_str -- head of the final string creation. Dumps	tree in out_str. Straightens out_str into newq_out. */char *tree_to_str(n)struct node *n;{	out_str[os_ptr_ind] = malloc(OS_STRING_SIZE*sizeof(char));	out_str[os_ptr_ind][0] = 0;	out_str[os_ptr_ind+1] = 0;	tree_dump(n);	return flat_copy(out_str);}/* tree_dump -- a recursive dump of a parse tree (into a string) */tree_dump(n)struct node *n;{	int i;	for (i = 0; n[i].val.ptr; i++)	{		if (n[i].s_or_p == TOK)		{			app_out_str(n[i].val.tok);			free(n[i].val.tok);		}		if (n[i].s_or_p == STR)		{			app_out_str(n[i].val.str);			/* free(n[i].val.str); */		}		if (n[i].s_or_p == PTR)		{			tree_dump(n[i].val.ptr);			/* free(n[i].val.ptr); */		}	}}/* app_out_str -- append to output string. Maintains out_str	during the tree_dump. */app_out_str(s)char *s;{	int len;	len = strlen(s);	if (len > (OS_STRING_SIZE - os_char_ind)) {		os_char_ind = 0;		os_ptr_ind++;		out_str[os_ptr_ind] = malloc(OS_STRING_SIZE*sizeof(char));		out_str[os_ptr_ind][0] = 0;		out_str[os_ptr_ind+1] = 0;	}	strcat(out_str[os_ptr_ind],s);	os_char_ind += len;}/* flat_copy -- copies 's_array' to 'd' and allocates space for 'd'.	Flattens out s_array into one long string. Returns 'd'. */char *flat_copy(s_array)char **s_array;{	int total, 	/* all the characters in s_array */	    ptr, ch, d_ind;  /* indices */	char *d;	/* count the number of characters in s_array */	total = 0;	for (ptr=0; out_str[ptr]; ptr++) {		for (ch = 0; out_str[ptr][ch]; ch++) {			total++;		}	}	/* allocate a string for the flattened version */	d = malloc((total+1)*sizeof(char));	/* copy s_array into d */	d_ind = 0;	for (ptr=0; out_str[ptr]; ptr++) {		for (ch = 0; out_str[ptr][ch]; ch++) {			d[d_ind++] = out_str[ptr][ch];		}		free(out_str[ptr]);	}	d[d_ind] = 0;	return d;}/* yyerror -- called by YACC to handle syntax errors. */yyerror(s)char *s;{	/* printf("%s\n",s); */	cancel(RCPDQ_SYNTAX);}/* newq_getc -- returns the next character from the input string */unsigned char newq_getc(){	unsigned char c;	c = newq_string[ns_ind];	if (c == 0) {		c = (unsigned char) EOF;	} else {		ns_ind++;	}	return c;}/* rec_getc -- returns the next character from the input string */char rec_getc(){	unsigned char c;	c = rec_string[rs_ind];	if (c == 0) {		c = (unsigned char) EOF;	} else {		rs_ind++;	}	return c;}/* object_string -- given an object number as defined in pardef.h	return the corresponding object string as defined in pdq.h. */char *object_to_string(object_num)int object_num;{	switch(object_num) {		case DB_NUM:			return DB_STRING;		case PROJECT_NUM: 			return PROJECT_STRING;		case RECORD_NUM:			return RECORD_STRING;		case RESERVE_NUM:			return RESERVE_STRING;		case RELPROC_NUM:			return RELPROC_STRING;		case ALERT_NUM:			return ALERT_STRING;	        case STORAGE_NUM:			return STORAGE_STRING;		default:			cancel(RCPDQ_BON);	}}/* up_strcmp -- just like strcmp but uppercases everything first. */up_strcmp(s1,s2)char *s1,*s2;{	int i;	for (i = 0; toupper(s1[i]) == toupper(s2[i]); i++) {		if (s1[i] == '\0') {			return (0);		}	}	return (s1[i] - s2[i]);}/* range_al -- allocates a range variable, puts it in a table along	with other table/range pairs, checks againt the range limit,	sets newq_out to an error if so. returns the range variable	string or a null string if error.*/char *range_al(table_name)char *table_name;{        char temp_name[PDB__ING_TAB_NAMESIZE];	if (pool_ind >= RANGE_LIMIT) {		cancel(RCPDQ_RANGE);		return "";	}	if (pdb__archive)	  sprintf(temp_name, "Z%s", table_name);	else          strcpy(temp_name, table_name);	range_list[range_ind].range = range_pool[pool_ind++];	pdb__range(range_list[range_ind].range,temp_name); 	range_list[range_ind++].table = table_name;		return range_list[range_ind-1].range;}/* base_joins -- creates a node pointer out of the resrve join	(if set) and the joins on all the tables.objid. */struct node *base_joins(list)char *list;{	int jind = 0,		nodal_size = 0,		i,j,ft_ind = 0;	struct node *joins;	char *s;	s = (char *) malloc(20);  /* needed length for sprintf below */	/* nodal size calculations */	if (reserve_flag == ON) {		nodal_size += 3;	}	if (range_ind > 1) {		nodal_size += ((range_ind-1)*4) +2;	}	if (nodal_size > 0) {		joins = pdq__nodes_al(nodal_size);	}	pdb_join_table = range_list[0].range;	/* add joins to node structure */	if (range_ind > 1) {		jsn(" and ( ");		for (i=1;i<range_ind;i++) {			jsn(pdb_join_table);			if ((object == RECORD_NUM) &&				(!up_strcmp(range_list[i].table,				RESERVE_STRING))) {				jsn(".id = ");			} else {				jsn(".objid = ");			}			jsn(range_list[i].range);			if ((range_ind-i)+1 > 2) {				if (!up_strcmp(range_list[i].table,					RESERVE_STRING)) {					jsn(".resobjid and \n");				} else {					jsn("objid and \n");				}			} else {				if (!up_strcmp(range_list[i].table,					RESERVE_STRING)) {					jsn(".resobjid");				} else {					jsn(".objid");				}			}		}	}		/* reserve joins */	if (reserve_flag == ON) {		jsn(" and \n ");		jsn(reserve_range);		sprintf(s,".objtype = %d \n",object);		jtn(s);	}	if (range_ind>1) {		jsn(" ) \n");	}	return joins;}/* a_o_base_joins -- creates a node pointer out of the reserve join	(if set) and the joins on all the tables.objid. */struct node *a_o_base_joins(){	int jind = 0,		nodal_size = 0,		i,j,ft_ind = 0;	struct node *a_o_joins = 0;	char *s;	s = (char *) malloc(20);  /* for sprintf below */	/* nodal size calculations */	if (reserve_flag == ON) {		nodal_size += 3;	}	if (a_o_r_ind > 1) {		nodal_size += ((a_o_r_ind)*4) +2;	}	if (nodal_size > 0) {		a_o_joins = pdq__nodes_al(nodal_size);	}	pdb_join_table = range_list[0].range;	/* add joins to node structure */	if (a_o_r_ind > 1) {		ajsn(" and ( ");		for (i=0;i<a_o_r_ind;i++) {			ajsn(pdb_join_table);			if ((object == RECORD_NUM) &&				(!up_strcmp(a_o_r_list[i].table,				RESERVE_STRING))) {				ajsn(".id = ");			} else {				ajsn(".objid = ");			}			ajsn(a_o_r_list[i].range);			if ((a_o_r_ind-i)+1 > 2) {				if (!up_strcmp(a_o_r_list[i].table,					RESERVE_STRING)) {					ajsn(".resobjid and \n");				} else {					ajsn("objid and \n");				}			} else {				if (!up_strcmp(a_o_r_list[i].table,					RESERVE_STRING)) {					ajsn(".resobjid");				} else {					ajsn(".objid");				}			}		}	}	/* reserve joins */	if (reserve_flag == ON) {		ajsn(" and \n ");		ajsn(reserve_range);		sprintf(s,".objtype = %d \n",object);		ajtn(s);	}	if (a_o_r_ind>1) {		ajsn(" ) \n");	}		a_o_r_ind = 0;	return a_o_joins;}/* init -- called from pdb_conv_... to re_initialize values	for next round */init(){ 	range_pool[0] = "pdba"; 	range_pool[1] = "pdbb"; 	range_pool[2] = "pdbc"; 	range_pool[3] = "pdbd"; 	range_pool[4] = "pdbe"; 	range_pool[5] = "pdbf"; 	range_pool[6] = "pdbg"; 	range_pool[7] = "pdbh"; 	range_pool[8] = "pdbi"; 	range_pool[9] = "pdbj"; 	range_pool[10] = (char *) 0;	pool_ind = 0;	a_o_r_ind = 0;	newq_out = "No result";	line = 1;	brace_state = 0;	brace_range = "";	a_o_flag = OFF;	rs_ind = 0;	ns_ind = 0;	rec_string = "";	os_ptr_ind = 0;	os_char_ind = 0;	range_ind = 0;	a_o_r_ind = 0;	recspec_state = OFF;	reserve_flag = OFF;	newq_return = OK;	reserve_range = "";	object_string = object_to_string(object);	pdb_join_table = range_al(object_string);	base_range = pdb_join_table;	yychar = -1; /* current input token number */	yyerrflag = 0;  /* error recovery flag */	yyprevious = YYNEWLINE;	yylineno = 1;	yy1char = -1; /* current input token number */	yy1errflag = 0;  /* error recovery flag */	yy1previous = YYNEWLINE;	yy1lineno = 1;	node_space_ind = 0;	dummy = &dummy_node;	rec_out = "";	rec_table = "";	yyleng = 0;	yymorfg = 0;	yytchar = 0;	yysptr = yysbuf;	yy1leng = 0;	yy1morfg = 0;	yy1tchar = 0;	desc_state = OFF;}/* cancel -- call a halt to everything by truncating our input string.	Set return error code. */cancel(err)int err;{	if (newq_return == OK) {		newq_return = err;	}	newq_string[ns_ind] = 0;}/* up_string -- given a string it actually modifies it, uppercasing	lower case letters. */up_string(s)char *s;{	for (;*s;s++) {		if ( (isalpha(*s)) && (islower(*s)) ) {			*s = toupper(*s);		}	}}/* get_table -- given a range name, returns the corresponding table name.	Does no checking ("yer on yer own, kid"). */char *get_table(s)char *s;{	int i;	for (i=0; i<range_ind; i++) {		if (!up_strcmp(s,range_list[i].range)) {			return range_list[i].table;		}	}}/* a_o_r_al -- allocates a range variable, puts it in a table along	with other table/range pairs, checks againt the range limit,	sets newq_out to an error if so. returns the range variable	string or a null string if error.*/char *a_o_r_al(table_name)char *table_name;{        char temp_name[PDB__ING_TAB_NAMESIZE];	if (pool_ind >= RANGE_LIMIT) {		cancel(RCPDQ_RANGE);		return "";	}	if (pdb__archive)	  sprintf(temp_name, "Z%s", table_name);	else	  strcpy(temp_name, table_name);	a_o_r_list[a_o_r_ind].range = range_pool[pool_ind++];	pdb__range(a_o_r_list[a_o_r_ind].range,temp_name); 	a_o_r_list[a_o_r_ind++].table = table_name;	return a_o_r_list[a_o_r_ind-1].range;}/* uc_subtree -- called by clause action from newq.y, this	routine uppercases all tokens marked with a UC attribute */uc_subtree(n)struct node *n;{	int i;	for (i=0;n[i].val.ptr;i++) {		if (n[i].s_or_p == PTR) {			uc_subtree(n[i].val.ptr);		} else {			if (n[i].attr == UC) {				up_string(n[i].val.tok);			}		}	}}